---
title: MySQL数据类型选择
tags: [MySQL]
---
##数据库类型选择
1.**选择正确的存储数据的最小数据类型**：
2.**简单就好**：整型比字符操作代价更低，主要是字符集和校对规则（排序规则）使字符比整型比较更加复杂；
两个特例：存储日期类使用内建的类型，要整型存储ip地址；
3.**尽量避免NULL**：
4.timesamp比datetime少一半的存储空间，允许的范围也更加的小；
###整数类型
TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT分别使用8,16,24,32,64位进行存储。
###实数类型
double占用8个字节，MySQL将其作为内部计算的类型；
decimal在需要进行精确计算时才使用。数据量比较大时，考虑BIGINT代替DECIMAL；以避免浮点存储计算不精确级DECIMAL精确计算代价高的问题。
###字符串类型
VARCHAR存储可变长字符串。需要额外的一到两个字节记录字符串长度（长度小于255个字节，用一个字节表示）。
CHAR是定长的，会更具需要采用空格进行填充以方便比较。例如CHAR适合存储密码的MD5值，这是一个定长的值。
注：每个字符最坏使用3个字节。
###BLOB和TEXT类型
为存储很大的数据而设计的字符串类型数据，分别采用二进制和字符方式存储；
###日期和时间类型
DATETIME：保存范围扼杀从1001到9999年，精度为秒，八个字节的存储空间。
TIMESTAMP：从1970年1月1日午夜到2038年，与Unix时间戳相同。

##乐观锁和悲观锁
###悲观锁：从数据开始更新就将数据锁住，直到更新完成才释放。
eg:
select * from account where name=”Erica” for update
这个语句会锁住所有符合条件的记录。其他可以读取但是不能修改和删除这些行，直到该语句的事务回滚或者提交。
缺点：会造成加锁时间过长，特别是长事务。
###乐观锁：准备提交所做的修改到数据库的时候才会将数据锁住。
实现方式是***1.数据库版本记录机制***，在每行数据加一个字段版本号来控制的。
工作原理就是读出是也把版本号读出，更新时把版本号加一；
只有提交的版本号大于当前数据的版本号则更新，否则需要重新读取数据做出更改。
***2.时间戳机制***：这个比较的是等于，而不是大于。
缺点：不能解决脏读问题。


##权限语句和收回权限语句
grant 权限 on 数据库对象 to 用户
权限包括：insert select update delete；
收回：revoke 


##索引
1.可以使用explain select * from c;来显示查询的参数。
2.索引优化：
3.1.索引字段越小越好，数据库以页为存储单位，字段越小，存储的数据越多；
3.2.***散列度大的列放在联合索引的前面，如何判断散列度：***
分别SELECT COUNT列得到数字越大，散列度越高。

3.3.
注意重复，冗余，无用索引。
###聚类和非聚类
根本的区别在于表中记录的顺序和索引的排列顺序是否一致的；
聚类索引：索引的叶节点就是数据节点。由于磁盘的空间优势在于范围查找会比较的快；
适用场合：某一列包含小数目的不同值；排序以及范围查找；
而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块；

涉及到的操作系统的知识：
我们先将计算机分为数个层次：
寄存器  64位
一级缓存L1 4×64KB
二级缓存L2 4×256KB
三级缓存L3 8MB
内存 4GB
磁盘 1TB
空间局部性+时间局部性；
###组合索引
Index(A,B,C):
不能使用上组合索引的情况：
不包括组合索引的首列字段；
排序是可用：
Index(A,B)：
ORDER BY A；A=5 ORDER BY B;
ORDER BY A desc, B desc;(顺序相同)；